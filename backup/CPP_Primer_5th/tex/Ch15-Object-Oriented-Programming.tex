\section{Object Oriented Programming}
\begin{itemize}

\item
The key idea in \textbf{object-oriented programming} are data abstraction, inheritance, and dynamic binding. Using data abstraction, we can define classes that separate interface from implementation. Through inheritance, we can define classes that model the relationships among similar types. Through dynamic binding, we can use objects of these types while ignoring the details of how they differ.

\item
In C\texttt{++}, a base class distinguishes functions that are type dependent from those that it expects its derived classes to inherit without change. The base class defines as \textbf{\textit{virtual}} those functions it expects its derived classes to define for themselves.

\item
A derived class must include in its own class body a declaration of all the virtual functions it intends to define for itself.

\item
Dynamic binding is sometimes known as \textbf{run-time binding}.

\item
In C\texttt{++}, dynamic binding happens when a virtual function is called through a reference (or a pointer) to a base class.

\item
Base classes ordinarily should define a virtual destructor. Virtual destructors are needed even if they do no work.

\item
The base class defines as \textbf{\textit{virtual}} those functions it expects its derived classes to override. When we call a virtual function \textit{through a pointer or reference}, the call will by dynamically bound.

\item
Any non\texttt{static} member function, other than a constructor, may be virtual. The \texttt{virtual} keyword appears only on the declaration inside the class and may not be used on a function definition that appears outside the class body. A function that is declared as \texttt{virtual} in the base class is implicitly \texttt{virtual} in the derived classes as well.

\item
A derived class must specify from which class(es) it inherits. It does so in its \textbf{class derivation list}, which is a colon followed by a comma-separated list of names of previously defined classes. Each base class name may be preceded by an optional access specifier, which is one of \texttt{public}, \texttt{protected}, or \texttt{private}.

\item
When the derivation is \texttt{public}, the \texttt{public} members of the base class become part of the interface of the derived class as well. In addition, we can bind an object of a publicly derived type to a pointer or reference to the base type.

\item
The new standard lets a derived class explicitly note that it intends a member function to override a virtual that it inherits. It does so by specifying \texttt{override} after the parameter list, or after the \texttt{const} or reference qualifier(s) if the member is a \texttt{const} or reference function.

\item
Because a derived object contains subparts corresponding to its base class(es), we can use an object of a derived type \textit{as if} it were an object of its base type(s).

\item
The base-class part of an object is initialized, along with the data members of the derived class, during the initialization phase of the constructor.

\item
The base class is initialized first, and then the members of the derived class are initialized in the order in which they are declared in the class.

\item
It is essential to understand that each class defines its own interface. Interactions with an object of a class-type should use the interface of that class, even if that object is the base-class part of a derived object.

\item
A class must be defined, not just declared, before we can use it as a base class.

\item
Under the new standard, we can prevent a class from being used as a base by following the class name with \texttt{final}.

\end{itemize}